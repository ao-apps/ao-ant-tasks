/*
 * ao-ant-tasks - Ant tasks used in building AO-supported projects.
 * Copyright (C) 2023  AO Industries, Inc.
 *     support@aoindustries.com
 *     7262 Bull Pen Cir
 *     Mobile, AL 36695
 *
 * This file is part of ao-ant-tasks.
 *
 * ao-ant-tasks is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ao-ant-tasks is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ao-ant-tasks.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.aoapps.ant.tasks;

import static com.aoapps.ant.tasks.SeoJavadocFilter.AT;
import static com.aoapps.ant.tasks.SeoJavadocFilter.AT_LINE;
import static com.aoapps.ant.tasks.SeoJavadocFilter.ENCODING;
import static com.aoapps.ant.tasks.SeoJavadocFilter.FILTER_EXTENSION;
import static com.aoapps.ant.tasks.SeoJavadocFilter.HEAD_ELEM_END;
import static com.aoapps.ant.tasks.SeoJavadocFilter.HEAD_ELEM_START;
import static com.aoapps.ant.tasks.SeoJavadocFilter.NL;
import static com.aoapps.ant.tasks.SeoJavadocFilter.NOINDEX;
import static com.aoapps.ant.tasks.SeoJavadocFilter.ROBOTS_PREFIX;
import static com.aoapps.ant.tasks.SeoJavadocFilter.ROBOTS_SUFFIX;
import static com.aoapps.ant.tasks.SeoJavadocFilter.readLinesWithEof;

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.SortedSet;
import java.util.TimeZone;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.logging.Logger;
import java.util.zip.ZipException;
import org.apache.commons.compress.archivers.zip.ExtraFieldUtils;
import org.apache.commons.compress.archivers.zip.GeneralPurposeBit;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;

/**
 * Generates <a href="https://www.sitemaps.org/">sitemap</a> at <code>sitemap.xml</code> with an index at
 * <code>META-INF/sitemap-index.xml</code>.  Excludes pages containing robots noindex.
 * The sitemap indexes will be automatically picked-up by
 * <a href="https://semanticcms.com/core/sitemap/">SemanticCMS Core Sitemap</a> and merged into the site's
 * total sitemap index.  The timestamp of the added <code>sitemap.xml</code> and <code>META-INF/sitemap-index.xml</code>
 * will be based on the most recent modified time they contain.
 * <p>
 * This does not have any direct Ant dependencies.
 * If only using this class, it is permissible to exclude the ant dependencies.
 * </p>
 *
 * @author  AO Industries, Inc.
 */
public final class GenerateJavadocSitemap {

  /** Make no instances. */
  private GenerateJavadocSitemap() {
    throw new AssertionError();
  }

  private static final Logger logger = Logger.getLogger(GenerateJavadocSitemap.class.getName());

  /**
   * The comment added to generated items.  This does not include any version number for reproducibility of manipulated
   * artifacts.
   */
  private static final String GENERATED_COMMENT = "Generated by " + GenerateJavadocSitemap.class.getName();

  /**
   * The ZIP entry containing the sitemap.
   */
  private static final String SITEMAP_NAME = "sitemap.xml";

  /**
   * The ZIP entry for <code>META-INF/</code> directory.
   */
  static final String META_INF_DIRECTORY = "META-INF/";

  /**
   * Treat generated javadocs with a fairly low priority.
   * See <a href="https://www.sitemaps.org/protocol.html#prioritydef">sitemaps.org - Protocol - &lt;priority&gt;</a>.
   */
  private static final String SITEMAP_PRIORITY = "0.1";

  /**
   * The ZIP entry containing the sitemap index.
   */
  // Note: Matches semanticcms-core-servlet:SiteMapIndexServlet.java:SERVLET_PATH (but without slash)
  // Note: Matches semanticcms-core-servlet:SiteMapIndexServlet.java:META_INF_SITEMAP_INDEX_NAME
  static final String SITEMAP_INDEX_NAME = "sitemap-index.xml";

  /**
   * One sitemap URL.
   */
  private static class SitemapPath implements Comparable<SitemapPath> {

    private final String entryName;
    private final long entryTime;

    private SitemapPath(String entryName, long entryTime) {
      this.entryName = entryName;
      if (entryTime == -1) {
        throw new IllegalArgumentException("entryTime == -1");
      }
      this.entryTime = entryTime;
    }

    @Override
    public int hashCode() {
      return (int) entryTime + entryName.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof SitemapPath)) {
        return false;
      }
      SitemapPath other = (SitemapPath) obj;
      return entryTime == other.entryTime && entryName.equals(other.entryName);
    }

    /**
     * Ordered by time descending then by name ascending.
     */
    @Override
    public int compareTo(SitemapPath other) {
      // Time descending
      int diff = Long.compare(other.entryTime, entryTime); // Reversed order for descending
      if (diff != 0) {
        return diff;
      }
      // Name ascending
      return entryName.compareTo(other.entryName);
    }
  }

  /**
   * Creates a date formatter.
   * See <a href="https://stackoverflow.com/a/3914498/7121505">java - How to get current moment in ISO 8601 format with
   * date, hour, and minute? - Stack Overflow</a>.
   */
  private static DateFormat createIso8601Format() {
    TimeZone tz = TimeZone.getTimeZone("UTC");
    DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'"); // Quoted "Z" to indicate UTC, no timezone offset
    df.setTimeZone(tz);
    return df;
  }

  /**
   * Generates the sitemap.
   */
  private static String generateSitemap(String apidocsUrlWithSlash, SortedSet<SitemapPath> sitemapPaths) {
    String apidocsUrlWithSlashXmlEscaped = StringEscapeUtils.escapeXml10(apidocsUrlWithSlash);
    DateFormat iso8601 = createIso8601Format();
    StringBuilder sitemap = new StringBuilder();
    sitemap.append("<?xml version=\"1.0\" encoding=\"").append(ENCODING).append("\"?>").append(NL);
    sitemap.append("<!-- ").append(StringEscapeUtils.escapeXml10(GENERATED_COMMENT)).append(" -->").append(NL);
    sitemap.append("<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">").append(NL);
    for (SitemapPath sitemapPath : sitemapPaths) {
      sitemap.append("  <url>").append(NL);
      sitemap.append("    <loc>");
      sitemap.append(apidocsUrlWithSlashXmlEscaped);
      sitemap.append(StringEscapeUtils.escapeXml10(sitemapPath.entryName));
      sitemap.append("</loc>").append(NL);
      sitemap.append("    <lastmod>");
      // Convert time to UTC
      long time = ZipTimestampMerge.offsetFromZipToUtc(sitemapPath.entryTime);
      sitemap.append(StringEscapeUtils.escapeXml10(iso8601.format(new Date(time))));
      sitemap.append("</lastmod>").append(NL);
      sitemap.append("    <priority>").append(SITEMAP_PRIORITY).append("</priority>").append(NL);
      sitemap.append("  </url>").append(NL);
    }
    sitemap.append("</urlset>").append(NL);
    return sitemap.toString();
  }

  /**
   * Generates the sitemap index.
   */
  private static String generateSitemapIndex(String apidocsUrlWithSlash, long sitemapLastModified) {
    StringBuilder sitemapIndex = new StringBuilder();
    sitemapIndex.append("<?xml version=\"1.0\" encoding=\"").append(ENCODING).append("\"?>").append(NL);
    sitemapIndex.append("<!-- ").append(StringEscapeUtils.escapeXml10(GENERATED_COMMENT)).append(" -->").append(NL);
    sitemapIndex.append("<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">").append(NL);
    sitemapIndex.append("  <sitemap>").append(NL);
    sitemapIndex.append("    <loc>");
    String apidocsUrlWithSlashXmlEscaped = StringEscapeUtils.escapeXml10(apidocsUrlWithSlash);
    sitemapIndex.append(apidocsUrlWithSlashXmlEscaped);
    sitemapIndex.append(StringEscapeUtils.escapeXml10(SITEMAP_NAME));
    sitemapIndex.append("</loc>").append(NL);
    sitemapIndex.append("    <lastmod>");
    // Convert time to UTC
    DateFormat iso8601 = createIso8601Format();
    long time = ZipTimestampMerge.offsetFromZipToUtc(sitemapLastModified);
    sitemapIndex.append(StringEscapeUtils.escapeXml10(iso8601.format(new Date(time))));
    sitemapIndex.append("</lastmod>").append(NL);
    sitemapIndex.append("  </sitemap>").append(NL);
    sitemapIndex.append("</sitemapindex>").append(NL);
    return sitemapIndex.toString();
  }

  /**
   * Copies some zip meta information from one entry to another.
   *
   * @see  ZipArchiveEntry#ZipArchiveEntry(java.util.zip.ZipEntry)
   * @see  ZipArchiveEntry#ZipArchiveEntry(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)
   */
  private static void copyZipMeta(ZipArchiveEntry from, ZipArchiveEntry to) throws ZipException {
    // ZipArchiveEntry#ZipArchiveEntry(java.util.zip.ZipEntry)
    final byte[] extra = from.getExtra();
    if (extra != null) {
      to.setExtraFields(ExtraFieldUtils.parse(extra, true, ZipArchiveEntry.ExtraFieldParsingMode.BEST_EFFORT));
    }
    to.setMethod(from.getMethod());

    // ZipArchiveEntry#ZipArchiveEntry(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)
    to.setInternalAttributes(from.getInternalAttributes());
    to.setExternalAttributes(from.getExternalAttributes());
    to.setExtraFields(from.getExtraFields(true));
    if (from.getPlatform() == ZipArchiveEntry.PLATFORM_UNIX) {
      to.setUnixMode(from.getUnixMode());
    }
    final GeneralPurposeBit other = from.getGeneralPurposeBit();
    to.setGeneralPurposeBit(other == null ? null : (GeneralPurposeBit) other.clone());
  }

  /**
   * Finds any robots header value.
   */
  private static String findRobotsHeader(File javadocJar, ZipArchiveEntry zipEntry, List<String> linesWithEof,
      Consumer<Supplier<String>> debug
  ) throws ZipException {
    // Find the <head> line
    int headStartIndex = linesWithEof.indexOf(HEAD_ELEM_START);
    if (headStartIndex == -1) {
      throw new ZipException(HEAD_ELEM_START.trim() + " not found: " + javadocJar + AT + zipEntry);
    }
    // Find the </head> line
    int headEndIndex = linesWithEof.indexOf(HEAD_ELEM_END);
    if (headEndIndex == -1) {
      throw new ZipException(HEAD_ELEM_END.trim() + " not found: " + javadocJar + AT + zipEntry);
    }
    if (headEndIndex < headStartIndex) {
      throw new ZipException(HEAD_ELEM_END.trim() + " before " + HEAD_ELEM_START.trim() + ": "
          + javadocJar + AT + zipEntry);
    }
    // Search for line with robots meta
    int finishedIndex = -1;
    String robotsValue = null;
    for (int lineIndex = headStartIndex + 1; lineIndex < headEndIndex; lineIndex++) {
      String lineWithEof = linesWithEof.get(lineIndex);
      if (lineWithEof.startsWith(ROBOTS_PREFIX)) {
        if (finishedIndex != -1) {
          throw new ZipException("duplicate element detected " + javadocJar + AT + zipEntry
              + " @ lines " + (finishedIndex + 1) + " and " + (lineIndex + 1));
        }
        if (!lineWithEof.endsWith(ROBOTS_SUFFIX)) {
          throw new ZipException("Expected line ending (" + ROBOTS_SUFFIX.trim() + ") missing: "
              + javadocJar + AT + zipEntry + AT_LINE + (lineIndex + 1));
        }
        String currentValue = lineWithEof.substring(ROBOTS_PREFIX.length(),
            lineWithEof.length() - ROBOTS_SUFFIX.length());
        debug.accept(() -> "Robots value found: " + currentValue);
        robotsValue = currentValue;
        finishedIndex = lineIndex;
      }
    }
    if (robotsValue == null) {
      debug.accept(() -> "No robots value found");
    }
    return robotsValue;
  }

  /**
   * Implementation of {@link #addSitemapToJavadocJar(java.io.File)}
   * with provided logging.
   */
  static void addSitemapToJavadocJar(
      File javadocJar,
      String apidocsUrl,
      Consumer<Supplier<String>> debug,
      Consumer<Supplier<String>> info,
      Consumer<Supplier<String>> warn
  ) throws IOException {
    info.accept(() -> "Generate Javadoc Sitemap processing " + javadocJar);
    // Validate
    Objects.requireNonNull(javadocJar, "javadocJar required");
    if (!javadocJar.exists()) {
      throw new IOException("javadocJar does not exist: " + javadocJar);
    }
    if (!javadocJar.isFile()) {
      throw new IOException("javadocJar is not a regular file: " + javadocJar);
    }
    Objects.requireNonNull(apidocsUrl, "apidocsUrl required");
    String apidocsUrlWithSlash;
    if (!apidocsUrl.endsWith("/")) {
      apidocsUrlWithSlash = apidocsUrl + "/";
    } else {
      apidocsUrlWithSlash = apidocsUrl;
    }
    File tmpFile = File.createTempFile(javadocJar.getName() + "-", ".jar", javadocJar.getParentFile());
    try (Closeable c = () -> {
      if (tmpFile.exists()) {
        FileUtils.delete(tmpFile);
      }
    }) {
      debug.accept(() -> "Writing temp file " + tmpFile);
      try (ZipArchiveOutputStream tmpZipOut = new ZipArchiveOutputStream(tmpFile)) {
        debug.accept(() -> "Reading " + javadocJar);
        try (ZipFile zipFile = new ZipFile(javadocJar)) {
          Set<String> sitemapNames = new HashSet<>();
          SortedSet<SitemapPath> sitemapPaths = new TreeSet<>();
          Enumeration<ZipArchiveEntry> zipEntries = zipFile.getEntriesInPhysicalOrder();
          while (zipEntries.hasMoreElements()) {
            ZipArchiveEntry zipEntry = zipEntries.nextElement();
            debug.accept(() -> "zipEntry: " + zipEntry);
            String zipEntryName = zipEntry.getName();
            // Require times on all entries
            long zipEntryTime = zipEntry.getTime();
            if (zipEntryTime == -1) {
              throw new ZipException("No time in entry: " + javadocJar + AT + zipEntryName);
            }
            if (zipEntryName.equals(SITEMAP_NAME) || zipEntryName.equals(META_INF_DIRECTORY + SITEMAP_INDEX_NAME)) {
              // Drop any existing sitemaps
              debug.accept(() -> zipEntryName + ": Dropping existing sitemap");
            } else {
              // Copy all other entriers verbatim
              try (InputStream rawStream = zipFile.getRawInputStream(zipEntry)) {
                tmpZipOut.addRawArchiveEntry(zipEntry, rawStream);
              }
            }
            if (StringUtils.endsWithIgnoreCase(zipEntryName, FILTER_EXTENSION)) {
              List<String> linesWithEof;
              try (Reader in = new BufferedReader(new InputStreamReader(zipFile.getInputStream(zipEntry), ENCODING))) {
                linesWithEof = readLinesWithEof(javadocJar, zipEntryName, in);
              }
              String originalHtml = StringUtils.join(linesWithEof, "");
              debug.accept(() -> zipEntryName + ": Read " + linesWithEof.size() + " lines, " + originalHtml.length()
                  + " characters");
              // Determine the robots header value
              String robotsHeader = findRobotsHeader(javadocJar, zipEntry, linesWithEof, debug);
              // Add to sitemap when not noindex
              if (robotsHeader == null || !robotsHeader.contains(NOINDEX)) {
                if (!sitemapNames.add(zipEntryName)) {
                  throw new ZipException("Duplicate name in " + javadocJar + ": " + zipEntryName);
                }
                if (!sitemapPaths.add(new SitemapPath(zipEntryName, zipEntryTime))) {
                  throw new AssertionError();
                }
              }
            }
          }
          // Refuse to create empty sitemaps
          if (sitemapPaths.isEmpty()) {
            throw new ZipException("Sitemap is empty, empty JAR?: " + javadocJar);
          }
          // Copy most ZIP entry attributes from the first entry used in the sitemap (unix mode, permissions, ...)
          ZipArchiveEntry referenceEntry = zipFile.getEntry(sitemapPaths.first().entryName);
          assert referenceEntry != null;
          // Generate sitemap.xml
          long sitemapLastModified = sitemapPaths.first().entryTime;
          assert sitemapLastModified >= sitemapPaths.last().entryTime : "Most recent is first";
          ZipArchiveEntry sitemapEntry = new ZipArchiveEntry(SITEMAP_NAME);
          copyZipMeta(referenceEntry, sitemapEntry);
          sitemapEntry.setTime(sitemapLastModified);
          sitemapEntry.setComment(GENERATED_COMMENT);
          tmpZipOut.putArchiveEntry(sitemapEntry);
          tmpZipOut.write(generateSitemap(apidocsUrlWithSlash, sitemapPaths).getBytes(ENCODING));
          tmpZipOut.closeArchiveEntry();
          // Require META-INF directory
          if (zipFile.getEntry(META_INF_DIRECTORY) == null) {
            throw new ZipException("Missing " + META_INF_DIRECTORY + " directory: " + javadocJar);
          }
          // Generate sitemap-index.xml
          ZipArchiveEntry sitemapIndexEntry = new ZipArchiveEntry(META_INF_DIRECTORY + SITEMAP_INDEX_NAME);
          copyZipMeta(referenceEntry, sitemapIndexEntry);
          sitemapIndexEntry.setTime(sitemapLastModified);
          sitemapIndexEntry.setComment(GENERATED_COMMENT);
          tmpZipOut.putArchiveEntry(sitemapIndexEntry);
          tmpZipOut.write(generateSitemapIndex(apidocsUrlWithSlash, sitemapLastModified).getBytes(ENCODING));
          tmpZipOut.closeArchiveEntry();
        }
      }
      // Ovewrite if anything changed, delete otherwise
      if (!FileUtils.contentEquals(javadocJar, tmpFile)) {
        if (!tmpFile.renameTo(javadocJar)) {
          throw new IOException("Rename failed: " + tmpFile + " to " + javadocJar);
        }
      } else {
        info.accept(() -> "Generate Javadoc Sitemap: No changes made (javadocs already processed?)");
      }
    }
  }

  /**
   * Adds a sitemap to a single JAR file as described in {@linkplain GenerateJavadocSitemap this class header}.
   *
   * @param javadocJar See {@link GenerateJavadocSitemapTask#setBuildDirectory(java.lang.String)}
   * @param apidocsUrl See {@link GenerateJavadocSitemapTask#setProjectUrl(java.lang.String)}
   */
  public static void addSitemapToJavadocJar(
      File javadocJar,
      String apidocsUrl
  ) throws IOException {
    GenerateJavadocSitemap.addSitemapToJavadocJar(
        javadocJar,
        apidocsUrl,
        logger::fine,
        logger::info,
        logger::warning
    );
  }
}
